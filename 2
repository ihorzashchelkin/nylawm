#include "nyla.h"

#include "utils.c"
#include <fcntl.h>
#include <xcb/xproto.h>

static const char* nylaCommand[] = {NULL, NULL};
static const char* termCommand[] = {"ghostty", NULL};

static FILE* logFile;
static xcb_connection_t* conn;
static int iscreen;
static xcb_screen_t* screen;
static NylaClient clients[64];
static NylaClient* activeClient;
static xcb_keycode_t activeChordKey;

#define X(key, grabbed) static xcb_keycode_t key##Keycode;
NYLA_KEYS(X)
#undef X

NYLA_XEVENT_HANDLER(map_request) {}

NYLA_XEVENT_HANDLER(map_notify) {}

NYLA_XEVENT_HANDLER(unmap_notify) {}

NYLA_XEVENT_HANDLER(key_press)
{
    if (!activeChordKey)
    {
        activeChordKey = e->detail;
        return;
    }
    if (e->detail == activeChordKey)
        return;

    if (activeChordKey == dKeycode)
    {
        if (e->detail == fKeycode)
        {
            if (activeClient)
            {
                NYLA_FOREACH_IF (client, activeClient + 1, NYLA_ARRAY_END(clients), client->window)
                {
                    NYLA_DLOG_FMT("using %lu", (u64)client);

                    xcb_map_window(conn, client->window);
                    nyla_focus_window(conn, client->window);
                    xcb_configure_window(conn,
                                         client->window,
                                         XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT | XCB_CONFIG_WINDOW_STACK_MODE,
                                         (u32[]){screen->width_in_pixels / 4, 0, screen->width_in_pixels / 2, screen->height_in_pixels, XCB_STACK_MODE_ABOVE});

                    if (activeClient)
                    {
                        xcb_configure_window(conn,
                                             activeClient->window,
                                             XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT,
                                             (i32[]){-screen->width_in_pixels / 4 * 0, 0, screen->width_in_pixels / 2, screen->height_in_pixels});
                    }

                    activeClient = client;
                    return;
                }

                NYLA_FOREACH_IF (client, clients, activeClient, client->window)
                {
                    NYLA_DLOG_FMT("using %lu", (u64)client);

                    xcb_map_window(conn, client->window);
                    nyla_focus_window(conn, client->window);
                    xcb_configure_window(conn,
                                         client->window,
                                         XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT | XCB_CONFIG_WINDOW_STACK_MODE,
                                         (u32[]){screen->width_in_pixels / 4, 0, screen->width_in_pixels / 2, screen->height_in_pixels, XCB_STACK_MODE_ABOVE});

                    if (activeClient)
                    {
                        xcb_configure_window(conn,
                                             activeClient->window,
                                             XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT,
                                             (i32[]){-screen->width_in_pixels / 4 * 0, 0, screen->width_in_pixels / 2, screen->height_in_pixels});
                    }

                    activeClient = client;
                    return;
                }
            }
            else
            {
                NYLA_FOREACH_IF (client, clients, NYLA_ARRAY_END(clients), client->window && client != activeClient)
                {
                    NYLA_DLOG_FMT("using %lu", (u64)client);

                    xcb_map_window(conn, client->window);
                    nyla_focus_window(conn, client->window);
                    xcb_configure_window(conn,
                                         client->window,
                                         XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT | XCB_CONFIG_WINDOW_STACK_MODE,
                                         (u32[]){screen->width_in_pixels / 4, 0, screen->width_in_pixels / 2, screen->height_in_pixels, XCB_STACK_MODE_ABOVE});

                    if (activeClient)
                    {
                        xcb_configure_window(conn,
                                             activeClient->window,
                                             XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT,
                                             (u32[]){screen->width_in_pixels / 4 * 3, 0, screen->width_in_pixels / 2, screen->height_in_pixels});
                    }

                    activeClient = client;
                    break;
                }
            }

            return;
        }

        if (e->detail == tKeycode)
        {
            nyla_spawn(conn, termCommand);
            return;
        }

        return;
    }

    if (activeChordKey == sKeycode)
    {
        if (e->detail == rKeycode)
            nyla_restart(conn, nylaCommand);

        if (e->detail == qKeycode)
            exit(EXIT_SUCCESS);

        return;
    }
}

NYLA_XEVENT_HANDLER(key_release)
{
    if (e->detail == activeChordKey)
        activeChordKey = 0;
}

NYLA_XEVENT_HANDLER(create_notify)
{
    if (e->override_redirect)
        return;

    NYLA_FOREACH_IF (client, clients, NYLA_ARRAY_END(clients), !client->window)
    {
        NYLA_DLOG_FMT("added %d", e->window);

        client->window = e->window;
        NYLA_ZERO_AFTER(client, window);

#if 0
        xcb_map_window(conn, client->window);
        nyla_focus_window(conn, client->window);
        xcb_configure_window(conn,
                             client->window,
                             XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT | XCB_CONFIG_WINDOW_STACK_MODE,
                             (u32[]){screen->width_in_pixels / 4, 0, screen->width_in_pixels / 2, screen->height_in_pixels, XCB_STACK_MODE_ABOVE});

        if (activeClient)
        {
            xcb_configure_window(conn,
                                 activeClient->window,
                                 XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT,
                                 (u32[]){screen->width_in_pixels / 4 * 3, 0, screen->width_in_pixels / 2, screen->height_in_pixels});
        }

        activeClient = client;
#endif
        break;
    }
}

NYLA_XEVENT_HANDLER(destroy_notify)
{
    NYLA_FOREACH_IF (client, clients, NYLA_ARRAY_END(clients), client->window == e->window)
    {
        NYLA_ZERO(client);
        break;
    }
}

NYLA_XEVENT_HANDLER(configure_request) {}

NYLA_XEVENT_HANDLER(configure_notify) {}

NYLA_XEVENT_HANDLER(client_message) {}

const char*
strXcbEventType(u8 type)
{
    switch (type)
    {
#define X(a, b)                                                                                                                                                                                        \
    case a: return #a;
        NYLA_XEVENTS(X)
#undef X
    }
    return "unknown";
}

void
nyla_refresh_keyboard()
{
    xcb_key_symbols_t* syms = xcb_key_symbols_alloc(conn);

#define X(key, isGrabbed)                                                                                                                                                                              \
    do                                                                                                                                                                                                 \
    {                                                                                                                                                                                                  \
        xcb_keycode_t* keycodes = xcb_key_symbols_get_keycode(syms, XK_##key);                                                                                                                         \
        key##Keycode = *keycodes;                                                                                                                                                                      \
        free(keycodes);                                                                                                                                                                                \
        if (isGrabbed)                                                                                                                                                                                 \
            xcb_grab_key(conn, 0, screen->root, XCB_MOD_MASK_4, key##Keycode, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC);                                                                               \
    }                                                                                                                                                                                                  \
    while (false);
    NYLA_KEYS(X)
#undef X

    xcb_key_symbols_free(syms);
}

NYLA_XEVENT_HANDLER(mapping_notify)
{
    // TODO: only if keyboard mapping
    nyla_refresh_keyboard();
}

NYLA_XEVENT_HANDLER(focus_in)
{
    if (activeClient)
        nyla_focus_window(conn, activeClient->window);
}

NYLA_XEVENT_HANDLER(focus_out)
{
    if (activeClient)
        nyla_focus_window(conn, activeClient->window);
}

int
main(int argc, const char* argv[])
{
    nylaCommand[0] = argv[0];

    {
        logFile = stderr;

        open("/home/izashchelkin/nylalog", O_APPEND | O_TRUNC | O_WRONLY);

        FILE* tmp = fopen(, "a+");
        NYLA_ASSERT(tmp, "could not open log file");
        logFile = tmp;
    }

    NYLA_DLOGs("\n\n<<<< STARTING >>>>\n");

    conn = xcb_connect(NULL, &iscreen);
    NYLA_ASSERT(conn, "could not connect to X server");

    screen = xcb_aux_get_screen(conn, iscreen);
    NYLA_ASSERT(screen, "could not get X screen");

    bool ok = !NYLA_XCB_CHECKED(
      xcb_change_window_attributes, screen->root, XCB_CW_EVENT_MASK, (u32[]){XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT | XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY | XCB_EVENT_MASK_FOCUS_CHANGE});
    NYLA_ASSERT(ok, "could not change root window attributes");

    nyla_refresh_keyboard();

    { // scanning
        xcb_query_tree_reply_t* reply = NYLA_XCB_REPLY(xcb_query_tree, screen->root);
        NylaClient* client = clients;
        for (xcb_window_t* it = xcb_query_tree_children(reply); it != xcb_query_tree_children_end(reply).data; ++it)
        {
            xcb_get_window_attributes_reply_t* reply = NYLA_XCB_REPLY(xcb_get_window_attributes, *it);
            if (!reply || reply->override_redirect)
                continue;

            (client++)->window = *it;
            xcb_unmap_window(conn, *it);
        }
        free(reply);
    }

    xcb_flush(conn);

    while (true)
    {
        while (true)
        {
            xcb_generic_event_t* e = xcb_poll_for_event(conn);
            if (!e)
                break;

            u8 type = e->response_type & ~0x80;
            if (type != XCB_MOTION_NOTIFY && type != XCB_KEY_PRESS && type != XCB_KEY_RELEASE)
                NYLA_DLOG_FMT("received event: %s", strXcbEventType(type));

            switch (type)
            {
#define X(_event, _type)                                                                                                                                                                               \
    case _event: nyla_handle_##_type((void*)e); break;
                NYLA_XEVENTS(X)
#undef X
            }
        }

        xcb_flush(conn);
    }

    xcb_disconnect(conn);
}
